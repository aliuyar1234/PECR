name: release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      mode:
        description: "Release mode (`full` builds artifacts, `republish` reuses existing artifacts)."
        required: true
        default: full
        type: choice
        options:
          - full
          - republish
      tag:
        description: "Release tag (example: v1.2.3)."
        required: true
        type: string
      source_run_id:
        description: "Required for `republish`: workflow run ID containing release artifacts."
        required: false
        type: string
      source_ref:
        description: "Optional source ref override for attestation verification (example: refs/tags/v1.2.3)."
        required: false
        type: string
      binaries_artifact_name:
        description: "Optional artifact name override for release binaries."
        required: false
        default: release-binaries
        type: string
      images_artifact_name:
        description: "Optional artifact name override for image digest manifest."
        required: false
        default: release-images
        type: string

permissions:
  contents: write
  packages: write
  id-token: write
  attestations: write

concurrency:
  group: release-${{ github.event_name == 'workflow_dispatch' && inputs.tag || github.ref_name }}
  cancel-in-progress: false

jobs:
  resolve_meta:
    runs-on: ubuntu-latest
    outputs:
      owner_lc: ${{ steps.meta.outputs.owner_lc }}
      tag: ${{ steps.meta.outputs.tag }}
      version: ${{ steps.meta.outputs.version }}
      publish_mode: ${{ steps.meta.outputs.publish_mode }}
      source_run_id: ${{ steps.meta.outputs.source_run_id }}
      source_ref: ${{ steps.meta.outputs.source_ref }}
      binaries_artifact_name: ${{ steps.meta.outputs.binaries_artifact_name }}
      images_artifact_name: ${{ steps.meta.outputs.images_artifact_name }}
    steps:
      - name: Resolve release metadata
        id: meta
        shell: bash
        env:
          MODE_INPUT: ${{ inputs.mode }}
          TAG_INPUT: ${{ inputs.tag }}
          SOURCE_RUN_ID_INPUT: ${{ inputs.source_run_id }}
          SOURCE_REF_INPUT: ${{ inputs.source_ref }}
          BIN_ARTIFACT_INPUT: ${{ inputs.binaries_artifact_name }}
          IMG_ARTIFACT_INPUT: ${{ inputs.images_artifact_name }}
        run: |
          set -euo pipefail

          if [[ "${GITHUB_EVENT_NAME}" == "push" ]]; then
            publish_mode="full"
          else
            publish_mode="${MODE_INPUT:-full}"
          fi

          if [[ -n "${TAG_INPUT:-}" ]]; then
            tag="${TAG_INPUT}"
          else
            tag="${GITHUB_REF_NAME}"
          fi
          if [[ "${tag}" != v* ]]; then
            echo "release tag must start with 'v' (got: ${tag})" >&2
            exit 1
          fi

          owner_lc="${GITHUB_REPOSITORY_OWNER,,}"
          version="${tag#v}"
          binaries_artifact_name="${BIN_ARTIFACT_INPUT:-release-binaries}"
          images_artifact_name="${IMG_ARTIFACT_INPUT:-release-images}"
          if [[ -z "${binaries_artifact_name// }" || -z "${images_artifact_name// }" ]]; then
            echo "artifact names must be non-empty" >&2
            exit 1
          fi
          if [[ "${binaries_artifact_name}" == "${images_artifact_name}" ]]; then
            echo "binaries and images artifact names must differ" >&2
            exit 1
          fi

          case "${publish_mode}" in
            full)
              source_run_id="${GITHUB_RUN_ID}"
              source_ref="${GITHUB_REF}"
              ;;
            republish)
              if [[ -z "${SOURCE_RUN_ID_INPUT:-}" ]]; then
                echo "source_run_id is required when mode=republish" >&2
                exit 1
              fi
              if ! [[ "${SOURCE_RUN_ID_INPUT}" =~ ^[0-9]+$ ]]; then
                echo "source_run_id must be a numeric GitHub run ID (got: ${SOURCE_RUN_ID_INPUT})" >&2
                exit 1
              fi
              source_run_id="${SOURCE_RUN_ID_INPUT}"
              source_ref="${SOURCE_REF_INPUT:-refs/tags/${tag}}"
              ;;
            *)
              echo "unsupported mode: ${publish_mode}" >&2
              exit 1
              ;;
          esac

          {
            echo "owner_lc=${owner_lc}"
            echo "tag=${tag}"
            echo "version=${version}"
            echo "publish_mode=${publish_mode}"
            echo "source_run_id=${source_run_id}"
            echo "source_ref=${source_ref}"
            echo "binaries_artifact_name=${binaries_artifact_name}"
            echo "images_artifact_name=${images_artifact_name}"
          } >> "${GITHUB_OUTPUT}"

  build_binaries:
    if: needs.resolve_meta.outputs.publish_mode == 'full'
    needs: resolve_meta
    runs-on: ubuntu-latest
    outputs:
      artifact_name: ${{ steps.artifact.outputs.name }}
    steps:
      - uses: actions/checkout@v4

      - name: Resolve artifact name
        id: artifact
        shell: bash
        run: |
          set -euo pipefail
          echo "name=${{ needs.resolve_meta.outputs.binaries_artifact_name }}" >> "${GITHUB_OUTPUT}"

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.91.1

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2

      - name: Build release binaries
        shell: bash
        run: |
          set -euo pipefail
          cargo build --locked --release -p pecr-gateway
          cargo build --locked --release -p pecr-controller --features rlm

      - name: Package artifacts with checksums
        shell: bash
        env:
          VERSION: ${{ needs.resolve_meta.outputs.version }}
        run: |
          set -euo pipefail
          mkdir -p release

          install -m 0755 target/release/pecr-gateway release/pecr-gateway
          tar -C release -czf "release/pecr-gateway_${VERSION}_linux_amd64.tar.gz" pecr-gateway
          rm -f release/pecr-gateway

          install -m 0755 target/release/pecr-controller release/pecr-controller
          tar -C release -czf "release/pecr-controller_${VERSION}_linux_amd64.tar.gz" pecr-controller
          rm -f release/pecr-controller

          (
            cd release
            sha256sum ./*.tar.gz > SHA256SUMS.txt
          )

      - name: Attest release binary provenance
        uses: actions/attest-build-provenance@v3
        with:
          subject-checksums: release/SHA256SUMS.txt

      - name: Attest release checksum manifest provenance
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: release/SHA256SUMS.txt

      - name: Upload release binary artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact.outputs.name }}
          path: release
          if-no-files-found: error

  build_images:
    if: needs.resolve_meta.outputs.publish_mode == 'full'
    needs: resolve_meta
    runs-on: ubuntu-latest
    outputs:
      artifact_name: ${{ steps.artifact.outputs.name }}
    steps:
      - uses: actions/checkout@v4

      - name: Resolve artifact name
        id: artifact
        shell: bash
        run: |
          set -euo pipefail
          echo "name=${{ needs.resolve_meta.outputs.images_artifact_name }}" >> "${GITHUB_OUTPUT}"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (gateway)
        id: gateway_meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ needs.resolve_meta.outputs.owner_lc }}/pecr-gateway
          tags: |
            type=raw,value=${{ needs.resolve_meta.outputs.tag }}
            type=sha
            type=raw,value=latest

      - name: Build and push gateway image
        id: gateway_build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/gateway.Dockerfile
          push: true
          tags: ${{ steps.gateway_meta.outputs.tags }}
          labels: ${{ steps.gateway_meta.outputs.labels }}

      - name: Docker metadata (controller)
        id: controller_meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ needs.resolve_meta.outputs.owner_lc }}/pecr-controller
          tags: |
            type=raw,value=${{ needs.resolve_meta.outputs.tag }}
            type=sha
            type=raw,value=latest

      - name: Build and push controller image
        id: controller_build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/controller.Dockerfile
          push: true
          tags: ${{ steps.controller_meta.outputs.tags }}
          labels: ${{ steps.controller_meta.outputs.labels }}

      - name: Emit image digest manifest
        shell: bash
        env:
          TAG: ${{ needs.resolve_meta.outputs.tag }}
          OWNER: ${{ needs.resolve_meta.outputs.owner_lc }}
          GATEWAY_DIGEST: ${{ steps.gateway_build.outputs.digest }}
          CONTROLLER_DIGEST: ${{ steps.controller_build.outputs.digest }}
        run: |
          set -euo pipefail
          mkdir -p release
          cat > release/image-digests.txt <<EOF
          tag=${TAG}
          gateway=ghcr.io/${OWNER}/pecr-gateway@${GATEWAY_DIGEST}
          controller=ghcr.io/${OWNER}/pecr-controller@${CONTROLLER_DIGEST}
          EOF

      - name: Attest gateway image provenance
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ghcr.io/${{ needs.resolve_meta.outputs.owner_lc }}/pecr-gateway
          subject-digest: ${{ steps.gateway_build.outputs.digest }}
          push-to-registry: true

      - name: Attest controller image provenance
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ghcr.io/${{ needs.resolve_meta.outputs.owner_lc }}/pecr-controller
          subject-digest: ${{ steps.controller_build.outputs.digest }}
          push-to-registry: true

      - name: Attest image digest manifest provenance
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: release/image-digests.txt

      - name: Upload release image manifest
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact.outputs.name }}
          path: release/image-digests.txt
          if-no-files-found: error

  publish_release:
    if: |
      always() &&
      needs.resolve_meta.result == 'success' &&
      (needs.build_binaries.result == 'success' || needs.build_binaries.result == 'skipped') &&
      (needs.build_images.result == 'success' || needs.build_images.result == 'skipped')
    needs:
      - resolve_meta
      - build_binaries
      - build_images
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Resolve publish artifact selectors
        id: publish_inputs
        shell: bash
        env:
          PUBLISH_MODE: ${{ needs.resolve_meta.outputs.publish_mode }}
          SOURCE_RUN_ID: ${{ needs.resolve_meta.outputs.source_run_id }}
          BUILD_BIN_ARTIFACT: ${{ needs.build_binaries.outputs.artifact_name }}
          BUILD_IMG_ARTIFACT: ${{ needs.build_images.outputs.artifact_name }}
          RESOLVED_BIN_ARTIFACT: ${{ needs.resolve_meta.outputs.binaries_artifact_name }}
          RESOLVED_IMG_ARTIFACT: ${{ needs.resolve_meta.outputs.images_artifact_name }}
        run: |
          set -euo pipefail

          if [[ "${PUBLISH_MODE}" == "republish" ]]; then
            binaries_artifact="${RESOLVED_BIN_ARTIFACT}"
            images_artifact="${RESOLVED_IMG_ARTIFACT}"
          else
            binaries_artifact="${BUILD_BIN_ARTIFACT}"
            images_artifact="${BUILD_IMG_ARTIFACT}"
          fi

          if [[ -z "${binaries_artifact}" || -z "${images_artifact}" ]]; then
            echo "artifact names could not be resolved (mode=${PUBLISH_MODE})" >&2
            exit 1
          fi
          if ! [[ "${SOURCE_RUN_ID}" =~ ^[0-9]+$ ]]; then
            echo "resolved source_run_id is not numeric: ${SOURCE_RUN_ID}" >&2
            exit 1
          fi

          {
            echo "source_run_id=${SOURCE_RUN_ID}"
            echo "binaries_artifact=${binaries_artifact}"
            echo "images_artifact=${images_artifact}"
          } >> "${GITHUB_OUTPUT}"

      - name: Fetch release artifacts with retry/backoff and validate checksums
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          SOURCE_RUN_ID: ${{ steps.publish_inputs.outputs.source_run_id }}
          BINARIES_ARTIFACT: ${{ steps.publish_inputs.outputs.binaries_artifact }}
          IMAGES_ARTIFACT: ${{ steps.publish_inputs.outputs.images_artifact }}
          ARTIFACT_DOWNLOAD_RETRIES: "5"
          ARTIFACT_DOWNLOAD_BACKOFF_SECS: "4"
        run: |
          set -euo pipefail

          download_artifact() {
            local run_id="$1"
            local artifact_name="$2"
            local destination="$3"
            rm -rf "${destination}"
            mkdir -p "${destination}"
            gh run download "${run_id}" \
              --repo "${GITHUB_REPOSITORY}" \
              --name "${artifact_name}" \
              --dir "${destination}"
          }

          copy_release_payload_files() {
            local source_dir="$1"
            find "${source_dir}" -type f \( \
              -name "*.tar.gz" -o \
              -name "SHA256SUMS.txt" -o \
              -name "image-digests.txt" \
            \) -print0 | while IFS= read -r -d '' file; do
              cp -f "${file}" "release/$(basename "${file}")"
            done
          }

          verify_payload_layout() {
            test -f release/SHA256SUMS.txt
            test -f release/image-digests.txt
            compgen -G "release/*.tar.gz" >/dev/null
          }

          attempts="${ARTIFACT_DOWNLOAD_RETRIES}"
          backoff="${ARTIFACT_DOWNLOAD_BACKOFF_SECS}"
          success=0

          for attempt in $(seq 1 "${attempts}"); do
            echo "Attempt ${attempt}/${attempts}: fetch artifacts from run ${SOURCE_RUN_ID}"
            rm -rf release _artifact_tmp
            mkdir -p release _artifact_tmp/binaries _artifact_tmp/images

            if ! download_artifact "${SOURCE_RUN_ID}" "${BINARIES_ARTIFACT}" "_artifact_tmp/binaries"; then
              echo "binary artifact download failed on attempt ${attempt}" >&2
            elif ! download_artifact "${SOURCE_RUN_ID}" "${IMAGES_ARTIFACT}" "_artifact_tmp/images"; then
              echo "image artifact download failed on attempt ${attempt}" >&2
            else
              copy_release_payload_files "_artifact_tmp/binaries"
              copy_release_payload_files "_artifact_tmp/images"
              if verify_payload_layout && (cd release && sha256sum --check SHA256SUMS.txt); then
                success=1
                break
              fi
              echo "artifact validation failed on attempt ${attempt}" >&2
            fi

            if [[ "${attempt}" -lt "${attempts}" ]]; then
              sleep_seconds=$((backoff * attempt))
              echo "Retrying in ${sleep_seconds}s..." >&2
              sleep "${sleep_seconds}"
            fi
          done

          if [[ "${success}" -ne 1 ]]; then
            echo "failed to fetch/validate release payload after ${attempts} attempts" >&2
            exit 1
          fi

          ls -lah release

      - name: Log in to GHCR for provenance verification
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify release provenance attestations
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          python3 scripts/security/verify_release_attestations.py \
            --release-dir release \
            --repo "${GITHUB_REPOSITORY}" \
            --signer-workflow "${GITHUB_REPOSITORY}/.github/workflows/release.yml" \
            --source-ref "${{ needs.resolve_meta.outputs.source_ref }}" \
            --deny-self-hosted-runners

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.resolve_meta.outputs.tag }}
          generate_release_notes: true
          fail_on_unmatched_files: true
          files: |
            release/*.tar.gz
            release/SHA256SUMS.txt
            release/image-digests.txt

      - name: Post-release smoke check
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          python3 scripts/security/release_smoke_check.py \
            --release-dir release \
            --repo "${GITHUB_REPOSITORY}" \
            --tag "${{ needs.resolve_meta.outputs.tag }}"
